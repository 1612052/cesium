*** should last row of availability just indicate if it has a child in those spots (to know if 0 sse or not)
and also indicate the external availability as normal but last row can't init tiles like the rest
of the subtree
*** only real reason to do the above is if 0 sse is really important and can't get rid of it
    I don't think you absolutely need 0 sse in the leaves, since there're examples working


[ ] Box array traversal
    [ ] Toroidial array stack (or whatever it will be)
    debug case: look down at teh tileset, print the center idx.
    successive levels should update at twice the rate.

    IndicesFinder
            hold off on bresenham just get box ranges of indices for now
            these will eventually be the visibliity indices (which are the request/render indces for add)
            replace will have to make sure to extend the loop a little in cases for sibling requests.
                literally just making sure the loop bounds starts and ends on an even number
                subtracting 1 for the loop start and adding 1 for the loop end if they were odd.

calcs in the patent doc show that all slabs are the same dimension on each level for their worst case.
related to the 27.7 constant that's there
So the data stucture would want to have the seams for the axes that it is managing (x, y for sure and z as well for octree)
the slab would have a 2d array of tile refs the dims of this array takes the min of the worst case dims for the level and the actual dims of the tree at that level.
if the seams indicate that portions of this 2d are beginning to be exposed, you can then calc the sphere imprint on the level and see if it would start to touch those exposed portions.
if it does we can trace teh circle in a virtual-centered space to see what index bounds on each row are, then we use this set of min/max indices to iterate over the tile ref array.
slabs could always be xy and octrees just have a set of these along z.

Not too sure about a slab of refs quite yet, this could be huge duplication of references?
In either case, generate the array of ranges (could it be an array on every level like? [[xmin, xmax, y, z], [same thing], ...])
use this pile of ranges to extract the relevant subtrees then use the ranges to request/select tiles in those subtrees.
