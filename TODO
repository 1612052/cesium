    May need a better representation of availability for tree that's more concise
    it would be nice if there was a maximum of 2 subtrees that spans the tree.
    A level 12 subtree can span levels 0-22
    Box style availability, while it has really bad worst case, its size is variable.
    and the common case should be quite small. It has early termination advantage.
    Not sure how well it compresses, but it's about as good as text (which looked to be 4x worse than the binary subtree)
    The terrain layer.json covers 16 levels(0-15) with 16K boxes which is 65KB uncompressed.
    Worst case is checkboard last level, would this show up in practice? Most trees are mostly full or mostly empty.
    Even if it doesn't compress well 65K uncompressed is still not a problem.
    The point is covering the tree in at most 2 subtrees so that skipLOD can just pull down a subtree and get rigth to work.
    If 2 isn't feasible, with 3 you could start prefetching subtrees below, so that the info is ready to go so you know which subtrees in
    the last layer of subtrees are available or not.

    IndicesFinder
    * The ellipsoid index generation could be scrapped for a little more simple dsqrd <= rsqrd
      checks since the fixed ellipsoid idea isn't going to work out(the conservative sampling idea won't work)
    * integer based ellipsoid tracing (bresenham) could work if we are ok with some level of error, i.e
        we "render" to a higher resolution screen but then upsample the resulting indices by the
        factor of resolution mulipier. Maybe this "error" is configurable. like are we ok with being off by 64th (or whatever) of a tile.
        only raster the rows closest the actual grid line

    PLANE DIST CALC:
    Experiment: Something like dot with closest corner to view dir and compare with cos of fov angles
Experiment: Local vesion of radEffective?
    Experiment: Play around with root level printing out when what plane fails, What the offset were what the distances were

    * OPT: no reason to check far plane
    * OPT: during plane culling wait to do the clipping until all planes ahve passed
      and .x is still not neg, push the distances and the plane indices, for later processing in the success this case
    * OPT: encorporate availability in index finding? done later in traversal,
      but the earlier you do it (culling rows that don't exist or clipping them down)
      the more needless calcs there are
    * Storage for this could be huge:
        * Do bresenham on the maximumTreversalLevel then infer up the tree.

    Maybe (too optimized for now):
    * use the min max indices per level to find a set of subtrees
        and group sets of indices with those subtrees
        for each min max on each level divide each  and see which subtree it falls into
        if not already in map of subtrees, add it and tack on the indices for the level

        would only have to do this on subtree transition levels since
        any levels below the transition level would have smaller spheres.
        so from startLevel to maximumTreversalLevel, skipping by distance to next
        subtree level, process the min max ranges for that level.
        basically take the min corner and the max corner, find out what their
        subtree root indexes are. sift the index ranges into subtree bins?

    these will eventually be the visibliity indices (which are the request/render indices for add)

So the data stucture would want to have the seams for the axes that it is managing (x, y for sure and z as well for octree)
the slab would have a 2d array of tile refs the dims of this array takes the min of the worst case dims for the level and the actual dims of the tree at that level.
if the seams indicate that portions of this 2d are beginning to be exposed, you can then calc the sphere imprint on the level and see if it would start to touch those exposed portions.
if it does we can trace teh circle in a virtual-centered space to see what index bounds on each row are, then we use this set of min/max indices to iterate over the tile ref array.
slabs could always be xy and octrees just have a set of these along z.

Not too sure about a slab of refs quite yet, this could be huge duplication of references?
In either case, generate the array of ranges (could it be an array on every level like? [[xmin, xmax, y, z], [same thing], ...])
use this pile of ranges to extract the relevant subtrees then use the ranges to request/select tiles in those subtrees.

traditional skipLOD traversal: tiny screen is usually 10-16 ms, full screen 40-60ms
