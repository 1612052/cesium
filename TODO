    IndicesFinder
    * The ellipsoid index generation could be scrapped for a little more simple dsqrd <= rsqrd
      checks since the fixed ellipsoid idea isn't going to work out(the conservative sampling idea wont work)

    PLANE DIST CALC:
    Experiment: Something like dot with closest corner to view dir and compare with cos of fov angles
Experiment: Local vesion of radEffective?
    Experiment: Play around with root level printing out when what plane fails, What the offset were what the distances were

    * OPT: no reason to check far plane
    * OPT: during plane culling wait to do the clipping until all planes ahve passed
      and .x is still not neg, push the distances and the plane indices, for later processing in the success this case
    * OPT: encorporate availability in index finding? done later in traversal,
      but the earlier you do it (culling rows that don't exist or clipping them down)
      the more needless calcs there are
    * Storage for this could be huge:
        * Do bresenham on the maximumTreversalLevel then infer up the tree.

    Maybe (too optimized for now):
    * use the min max indices per level to find a set of subtrees
        and group sets of indices with those subtrees
        for each min max on each level divide each  and see which subtree it falls into
        if not already in map of subtrees, add it and tack on the indices for the level

        would only have to do this on subtree transition levels since
        any levels below the transition level would have smaller spheres.
        so from startLevel to maximumTreversalLevel, skipping by distance to next
        subtree level, process the min max ranges for that level.
        basically take the min corner and the max corner, find out what their
        subtree root indexes are. sift the index ranges into subtree bins?

    these will eventually be the visibliity indices (which are the request/render indices for add)

So the data stucture would want to have the seams for the axes that it is managing (x, y for sure and z as well for octree)
the slab would have a 2d array of tile refs the dims of this array takes the min of the worst case dims for the level and the actual dims of the tree at that level.
if the seams indicate that portions of this 2d are beginning to be exposed, you can then calc the sphere imprint on the level and see if it would start to touch those exposed portions.
if it does we can trace teh circle in a virtual-centered space to see what index bounds on each row are, then we use this set of min/max indices to iterate over the tile ref array.
slabs could always be xy and octrees just have a set of these along z.

Not too sure about a slab of refs quite yet, this could be huge duplication of references?
In either case, generate the array of ranges (could it be an array on every level like? [[xmin, xmax, y, z], [same thing], ...])
use this pile of ranges to extract the relevant subtrees then use the ranges to request/select tiles in those subtrees.

traditional skipLOD traversal: tiny screen is usually 10-16 ms, full screen 40-60ms
