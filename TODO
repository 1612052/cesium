*** should last row of availability just indicate if it has a child in those spots (to know if 0 sse or not)
and also indicate the external availability as normal but last row can't init tiles like the rest
of the subtree
*** only real reason to do the above is if 0 sse is really important and can't get rid of it
    I don't think you absolutely need 0 sse in the leaves, since there're examples working


[ ] Box array traversal
    [ ] Toroidial array stack (or whatever it will be)
    debug case: look down at teh tileset, print the center idx.
    successive levels should update at twice the rate.

    looking at the x y z sides of the box and zooming out and making sure min max makes sense

    once radius is found just leoop with the box and not the circle for now
    need a thing to gather subtrees for blob of index ranges
        the subtree root resolve will help but don't run that per idx
        basically every level, it needs to check for subtree boundary jumps
        and bin the index ranges per subtree
        could do a swap-back or whatever
        then a subtree gets assigned a range into the array that holds all the indices

    IndicesFinder
    * CAN'T just do 3 perp profiles and intersect them together. see https://evanw.github.io/csg.js/ where you intersect 3 cylinders
    * you will have to do a stack of slices:

    // Here's a 2 loop midpoint slice stack impl
    // the outer loop generates the ring slice radii along the up direction (y in this case)
    // the inner loop uses that radii to generate the circl slice in the xz plane at y
    // assuming c is the center point
    // midpointCircle is the mid point circle algo that gets list of points and the radius error term of a circle with center at the origin.
    function sphere(c, radius, outList) {
        // get list of index points for the upper left quadrant and the radiusError
        const list = midpointCircle(radius);
        for {p, radiusError} of list {
            const listSlice = midpointCircle(pSlice.x, radiusError);
            for {pSlice, dontcare} of listSlice {
                // The particular octant of the sphere that each line corresponds to
                // depends on what quadrant midpointCircle generates and handedness of axes
                outList.push(c.x + pSlice.x, c.y + p.y, c.z + pSlice.y);
                outList.push(c.x + pSlice.x, c.y + p.y, c.z - pSlice.y);
                outList.push(c.x - pSlice.x, c.y + p.y, c.z + pSlice.y);
                outList.push(c.x - pSlice.x, c.y + p.y, c.z - pSlice.y);
                outList.push(c.x + pSlice.x, c.y - p.y, c.z + pSlice.y);
                outList.push(c.x + pSlice.x, c.y - p.y, c.z - pSlice.y);
                outList.push(c.x - pSlice.x, c.y - p.y, c.z + pSlice.y);
                outList.push(c.x - pSlice.x, c.y - p.y, c.z - pSlice.y);
            }
        }
    }

    float version of geeksforgeeks circle algo that's here https://www.geeksforgeeks.org/mid-point-circle-drawing-algorithm/
        https://ide.geeksforgeeks.org/QGRgv1EEN5
    Ellipse:
        https://www.geeksforgeeks.org/midpoint-ellipse-drawing-algorithm/
    Some other site with list of examples
        http://members.chello.at/~easyfilter/bresenham.html

    * Precompute a lattice / spine thing for the ellipsoid during init then during runtime update the runtime lattic/spine thing
      using the camera center cell inner fractional position to offset the precomputed lattice.
    * there needs to be something to handle poke through when the camera offset would cause
      another layer of the lattice to form (can one be removed from the other end?)

        Maybe (too optimized for now):
        * use the min max indices per level to find a set of subtrees
          and group sets of indices with those subtrees
          for each min max on each level divide each  and see which subtree it falls into
          if not already in map of subtrees, add it and tack on the indices for the level

          would only have to do this on subtree transition levels since
          any levels below the transition level would have smaller spheres.
          so from startLevel to maximumTreversalLevel, skipping by distance to next
          subtree level, process the min max ranges for that level.
          basically take the min corner and the max corner, find out what their
          subtree root indexes are. sift teh index ranges into subtree bins?

        * probably only need to trace the lodDistance sphere on each plane face
         given the camera position within the continuous grid. Then clip
          index bounds considering the min/max tree indices as well as the
          min/max lodDistance circle trace indices on each plane face.
        * avoid the sqrt if it turns out you just need the radiiToTileRatios more than the radii array
        * can it be done in a way that can be lerp'd based on center position fraction (not a linear thing?)

        hold off on bresenham just get box ranges of indices for now
        these will eventually be the visibliity indices (which are the request/render indces for add)
        replace will have to make sure to extend the loop a little in cases for sibling requests.
            literally just making sure the loop bounds starts and ends on an even number
            subtracting 1 for the loop start and adding 1 for the loop end if they were odd.

So the data stucture would want to have the seams for the axes that it is managing (x, y for sure and z as well for octree)
the slab would have a 2d array of tile refs the dims of this array takes the min of the worst case dims for the level and the actual dims of the tree at that level.
if the seams indicate that portions of this 2d are beginning to be exposed, you can then calc the sphere imprint on the level and see if it would start to touch those exposed portions.
if it does we can trace teh circle in a virtual-centered space to see what index bounds on each row are, then we use this set of min/max indices to iterate over the tile ref array.
slabs could always be xy and octrees just have a set of these along z.

Not too sure about a slab of refs quite yet, this could be huge duplication of references?
In either case, generate the array of ranges (could it be an array on every level like? [[xmin, xmax, y, z], [same thing], ...])
use this pile of ranges to extract the relevant subtrees then use the ranges to request/select tiles in those subtrees.
