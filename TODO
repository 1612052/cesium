*** should last row of availability just indicate if it has a child in those spots (to know if 0 sse or not)
and also indicate the external availability as normal but last row can't init tiles like the rest
of the subtree
*** only real reason to do the above is if 0 sse is really important and can't get rid of it
    I don't think you absolutely need 0 sse in the leaves, since there're examples working

    IndicesFinder
    REPLACE: refine will have to make sure to extend the loop a little in cases for sibling requests.
    literally just making sure the loop bounds starts and ends on an even number
    subtracting 1 for the loop start and adding 1 for the loop end if they were odd.
        // TODO:
        // 1) process the pre-clipped levelElliposoid to add the sibling indices directly to levelEllipsoid (extending x ranges and adding rows)
            // the x should be simple enough, the y and z must make sure they continue on, clipped to the tree bounds
        // 2) clip the indices with the planes as normal
        // 3) post-process the clipped levelElliposoid to generate set of indices that need to be requested but not rendered
        //   (this will be the end siblings or entire rows (range copied from visible sibling row))


    PLANE DIST CALC:
    Experiment: local vesion of radEffective?
    Experiment: play around with root level printing out when what plane fails
    what the offset were what the distances were

    * OPT: no reason to check far plane
    * OPT: during plane culling wait to do the clipping until all planes ahve passed
      and .x is still not neg, push the distances and the plane indices, for later processing in the success this case
    * OPT: encorporate availability in index finding? done later in traversal,
      but the earlier you do it (culling rows that don't exist or clipping them down)
      the more needless calcs there are
    * Storage for this could be huge:
        * Do bresenham on the maximumTreversalLevel then infer up the tree.

    Maybe (too optimized for now):
    * use the min max indices per level to find a set of subtrees
        and group sets of indices with those subtrees
        for each min max on each level divide each  and see which subtree it falls into
        if not already in map of subtrees, add it and tack on the indices for the level

        would only have to do this on subtree transition levels since
        any levels below the transition level would have smaller spheres.
        so from startLevel to maximumTreversalLevel, skipping by distance to next
        subtree level, process the min max ranges for that level.
        basically take the min corner and the max corner, find out what their
        subtree root indexes are. sift the index ranges into subtree bins?

    these will eventually be the visibliity indices (which are the request/render indices for add)

So the data stucture would want to have the seams for the axes that it is managing (x, y for sure and z as well for octree)
the slab would have a 2d array of tile refs the dims of this array takes the min of the worst case dims for the level and the actual dims of the tree at that level.
if the seams indicate that portions of this 2d are beginning to be exposed, you can then calc the sphere imprint on the level and see if it would start to touch those exposed portions.
if it does we can trace teh circle in a virtual-centered space to see what index bounds on each row are, then we use this set of min/max indices to iterate over the tile ref array.
slabs could always be xy and octrees just have a set of these along z.

Not too sure about a slab of refs quite yet, this could be huge duplication of references?
In either case, generate the array of ranges (could it be an array on every level like? [[xmin, xmax, y, z], [same thing], ...])
use this pile of ranges to extract the relevant subtrees then use the ranges to request/select tiles in those subtrees.

Finish replace refine.
Work spec again.
Ignore global for now, keep working toward skipLOD.

=========
Questions
=========
What are the most frustrating aspects of the current solution
Imagine the perfect app, what are its top 3 features,? how do you interact with it? (voice  commands?  one hand?)
how fast does the data need to update/re-scan?
