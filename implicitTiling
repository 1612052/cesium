spheres idea
https://github.com/AnalyticalGraphicsInc/agi-cesium/issues/714

socom issue
https://github.com/AnalyticalGraphicsInc/agi-cesium-services/issues/65

implicit tiling
https://github.com/AnalyticalGraphicsInc/agi-swayze/issues/1420

root transform.
asset
gerror for root and gerrors are derived from that (knowing that its quad oct bin)
bounding volume (should just be height for map based trees), bounds derived for children from there
quadtree: give me tile at level z node x,y

tileset of tilesets, i.e. external tilesets (fetching json vs b3dm) cmpt wrapper? no extesions, just magic checks.
mix implicit and custom(tileset.json as it is today)

Custom binary can be unwieldy to deal with. strike a balance of size vs usability

actual terrain layer.json is huge 10+ MB they split it up now so that level 0 has it and level 10 tiles have it (to cover 20 levels in 2 fetch stages)

[x] Use roadhouse to generate a few levels using shehzan's instructions
Here are the steps:
• Use branch: https://github.com/AnalyticalGraphicsInc/agi-swayze/tree/fix-implicit-tiling-output
• Download data at: https://drive.google.com/open?id=1Zqbmm-5mAakwkXmyYG7-JAHaGJck0Uct
• To create a tileset, say at level 13 do:
./bin/roadHouse.js -I Database --disable-geometry-compression -i ~/data/NYC-12-CE-G-0.sqlite3 --tiler TMSGeodetic -x 8 -o ~/data/implicitRoadhouse/NYC-13 --content-level 13
• You can repeat this for as many levels as you want. Then combine all the directories and you'll get a replacement refinement tree (edited)
Maybe do 9-13
Can almost ignore the json use the root min max height as min max height for everything
Probably need the terrain way of calculating the sse (should i just find alaska.terraindb and use terrain to 3dtiles converter)
Don't need boundingVolume since region is implicit (height is not, at least for quadtree)
[x] Replace/add hint b3dm hint in properties hints
[x] Remove extensions
[x] Find an example layers.json
Content bounding volume can be had from the glb
if "root"exists then its traditional if "tilingScheme" exists then it's implicit
  * type: quad, oct, tms, wtms, cdb, xyz
  * transform
  * height min/max (implies long lat subdivision) OR boundingBox (implies subdivision within that bounding box)
  * availability: layers.json, double single head implied from this
  * geometric error of root, others derived from this (see calculation in terrain to 3dtiles converter)
  * content boundingbox is in the glb's minmax of positions so actual geom error could be the diag of this box?
  [x] Should provide a hint to amount of heads it is based on, though you could figure it out give the boundingRegion and first availability
  [x] Be able to consume non single head inputs (just versions of the layer.json with upper levels removed)
        headCount: x,y,z // so we can correlate two georef tilesets with different rootHeadCounts
        have a situation where teh bounds are loose fitting, need to know the spacing on the level give the headcount

  [x] Try a local tileset (splits don't ref a 2d map lat long)  with a tileset transform (pointclouds?)
    pointclouds .pnts files are a morton index(xyz bits interleved) where 0 0 0 is bottom lower left. looking down at the grid
    x is to the right y is up and z points at face
    * octree folder structure is level/z/x/y to make it easy to strip out quad tree layers or make it easier to octree-ize something
    * might be best if dimensions are all in reverse order (ex: level/z/y/x, level/y/x, level/x)
      so that as you insert dims the structure changes the least, makes it easy to correlate tree structures that are of different dimensions (oct vs quad)
    * "bi" trees could be easily  supported
    oritentedBoundingBox: center(cartesian3), halfAxes (matrix3 col maj)

  [ ] external tileset
        Don't pollute the uri z/x/y namespace they should be reserved for tiles (extensionless)
        layerExternal.json is the availability of the z/x/yLayer.json (which provides availability for that node and down)

  might need to construct to to a single tile to avoid accumulating error(n*spacing)??? otherwise contentless root will take the the bound
  if it is a root with a bunch of nodes determine the spacing on that level and the bounds of each. otherwise just subdivide from parent
* All tilesets  with same splits is powerful (merging/diffing/always have context to other tilesets)
    NOTE: the below is the same as stopping arbitrarily at any level when tiling
    the below would be like having a root 0 (its layer.json 0 would have the availability of all the tiles there)
    at any level of the 2d map implicit grid. the root grid lower left is then able to live anywhere, though this is probably a drawback
    since you then loose the reference fixed grid that cdb ensures(any x,y,z and headedness knowledge gives you the long lat bounds)

        something to consider:
        Single vs double is trivial to support (both in the terrain to 3dtiles converter and the first pass impl) so it might be really beneficially to take it a step further and have a field in `tilingScheme` called `headCount: {x,y,z}` where x y z would be your root level head resolution (how many heads in each dir). For example a single head would be 1,1,1, double would be 2,1,1
        The reason for extending it to support arbitary amount of heads is that:
        1. implementation-wise, they are just controlling the exponent power of two split calculations at the end of the day so its not really a source a head-ache.
        2. it helps the fixed grid system map onto awkward or non-homogenous data like a 3d pointcloud where density isnt so even (sparse but dense). It helps it get a head start on subdivision and load balancing the tree.

 * Just build a tree from the tile availablity and the root tile bound then traverse as normal
 * Each level has a fixed gError
 * if lat long based maybe don't provide a geom error (just assume its the same as global terrain and do sse that same way with that same function (see terrain to 3dtiles converter))
 * camera height off ellisoid probably tells you min level
 * and then some progressive ring distances away tell you level switches
 * those ring distaces would be like traveling back up, in fact you could precalc these elevation min z changes for a given maxSSE
 * and the delta between the elevation min z changes tell you the progressive ring distances.
 * I want a function that given a camera, culling volume, and tileset, get a list of z,x,y coords I need to request
 * consult availability to trim this list then assign priorities
 * so that the z/x/y is only reserved for tiles could have an externalAvailibility.json that tells you ranges of
 * layer.jsons in that are named z/x/ylayer.json that tell you the availablity for that tile and below
 * TODO: how to make this not insane in terms of when you hit level 10 and then suddelny need to request a bunch of jsons?
 * i.e. how to stagger?

 * What does terrain do? does it just build a tree from the layer.json?
 * FILES OF NOTE:
        Scene/Globe.js // has members like terrainProvider, imageryLayerCollection, maxsse, quadtreeprim, ellipsoid
                        // has functions for ray intersection
        Scene/QuadtreePrimitive.js // This is like 3dtileset AND traversal
        Scene/QuadtreeTile.js // This is sort of like 3dtile
        Scene/GlobeSurfaceTileProvider.js // This is sort of like traversal but makes requests, renders and get dist. Its quadtree is QuadtreePrimitive
        Core/EllipsoidTerrainProvider.js
        Core/CesiumTerrainProvider.js
        Core/GeographicTilingScheme.js // NOTE: Has a bunch of rect convertsions (pos, xy, etc)
        Core/TilingScheme.js // The interface of *TilingScheme.js files
        Core/TerrainProvider.js // The interface of *TerrainProvider.js files
 * Will probably be heavily inspired by CesiumTerrainProvider.js

/////////////USEFUL CODE////////////////////////

    NOTE: TerrainProvider.js
    /**
     * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will
     * ensure that adjacent heightmap vertices are separated by no more than
     * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.
     * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the
     * screen pixels between adjacent heightmap vertices and thus rendering more quickly.
     * @type {Number}
     */
    TerrainProvider.heightmapTerrainQuality = 0.25;
    /**
     * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.
     *
     * @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.
     * @param {Number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.
     * @param {Number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.
     * @returns {Number} An estimated geometric error.
     */
    TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function(ellipsoid, tileImageWidth, numberOfTilesAtLevelZero) {
        return ellipsoid.maximumRadius * 2 * Math.PI * TerrainProvider.heightmapTerrainQuality / (tileImageWidth * numberOfTilesAtLevelZero);
    };

    NOTE: CesiumTerrainProvider.js
    this._tilingScheme = new GeographicTilingScheme({
        numberOfLevelZeroTilesX : 2,
        numberOfLevelZeroTilesY : 1,
        ellipsoid : options.ellipsoid
    });
    this._heightmapWidth = 65;
    this._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid, this._heightmapWidth, this._tilingScheme.getNumberOfXTilesAtLevel(0));

/////////////USEFUL CODE////////////////////////
