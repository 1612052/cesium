*** should last row of availability just indicate if it has a child in those spots (to know if 0 sse or not)
and also indicate the external availability as normal but last row can't init tiles like the rest
of the subtree
*** only real reason to do the above is if 0 sse is really important and can't get rid of it
    I don't think you absolutely need 0 sse in the leaves, since there're examples working

[ ] Box array traversal
    [ ] Toroidial array stack (or whatever it will be)
    debug case: look down at teh tileset, print the center idx.
    successive levels should update at twice the rate.

    looking at the x y z sides of the box and zooming out and making sure min max makes sense

    once radius is found just loop with the box and not the circle for now
    need a thing to gather subtrees for blob of index ranges
        the subtree root resolve will help but don't run that per idx
        basically every level, it needs to check for subtree boundary jumps
        and bin the index ranges per subtree
        could do a swap-back or whatever
        then a subtree gets assigned a range into the array that holds all the indices

    IndicesFinder
    * TODO: still has issues(culling too early) but much better
    * TODO: I think the planes are formulated incorrectly(distance is opposite what it should be)
      at the start but work by happenstance since plane distance is added instead of subtracted
      when the planes are reformed in array space need to use the correct version of plane distance?
    * OPT: Near is probably the most important to do first since it culls half, then left right, then bot top, can skip far
    * OPT: You could sort the indices by moving all the neg .x to the back and saying how many valid there are.
      look into managed array since i think it has 2 different lengths
    * OPT: during plane culling wait to do the clipping until all planes ahve passed
      and .x is still not neg, push the distances and the plane indices, for later processing in the success this case
    * OPT: encorporate availability in index finding?
    * For size/iteration length management, could use a managed array and the level ellipsoid
      is clamped to the dims of the tree on that level. the managed array size is reserved for worst case.
    * Storage for this could be huge: technically only need to bresenham on the maximumTreversalLevel then infer up the tree.
      this lowest level bresenham can be done during finder.updateCameraLevelInfo,
      then when calling updateLevelEllipsoid you derive the vis indices from this lowest level ref
      for the given level (probably some pow2 manip as usual).
    * for the fixed version, have a spill over array for these extra spine bones
        with a managed array you could reserve for worst case and add them to main collection

    Maybe (too optimized for now):
    * use the min max indices per level to find a set of subtrees
        and group sets of indices with those subtrees
        for each min max on each level divide each  and see which subtree it falls into
        if not already in map of subtrees, add it and tack on the indices for the level

        would only have to do this on subtree transition levels since
        any levels below the transition level would have smaller spheres.
        so from startLevel to maximumTreversalLevel, skipping by distance to next
        subtree level, process the min max ranges for that level.
        basically take the min corner and the max corner, find out what their
        subtree root indexes are. sift the index ranges into subtree bins?

    these will eventually be the visibliity indices (which are the request/render inidces for add)
    REPLACE refine will have to make sure to extend the loop a little in cases for sibling requests.
        literally just making sure the loop bounds starts and ends on an even number
        subtracting 1 for the loop start and adding 1 for the loop end if they were odd.

So the data stucture would want to have the seams for the axes that it is managing (x, y for sure and z as well for octree)
the slab would have a 2d array of tile refs the dims of this array takes the min of the worst case dims for the level and the actual dims of the tree at that level.
if the seams indicate that portions of this 2d are beginning to be exposed, you can then calc the sphere imprint on the level and see if it would start to touch those exposed portions.
if it does we can trace teh circle in a virtual-centered space to see what index bounds on each row are, then we use this set of min/max indices to iterate over the tile ref array.
slabs could always be xy and octrees just have a set of these along z.

Not too sure about a slab of refs quite yet, this could be huge duplication of references?
In either case, generate the array of ranges (could it be an array on every level like? [[xmin, xmax, y, z], [same thing], ...])
use this pile of ranges to extract the relevant subtrees then use the ranges to request/select tiles in those subtrees.

=========
Questions
=========
